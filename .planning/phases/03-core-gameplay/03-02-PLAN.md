---
phase: 03-core-gameplay
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/Scene/Projectile.tsx
  - src/components/Scene/ProjectileManager.tsx
  - src/hooks/useMarkedFiles.ts
  - src/hooks/useProjectilePool.ts
  - src/components/Scene/FileBlocks.tsx
  - src/components/Scene/Tank.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can fire a neon energy bolt by clicking the mouse"
    - "First shot on a file marks it with pulsing red/orange glow"
    - "Second shot on a marked file sends it to OS recycle bin"
    - "User can mark multiple files then delete all marked at once via keyboard shortcut"
    - "Deleted file block plays de-rez dissolution animation and disappears from scene"
  artifacts:
    - path: "src/hooks/useMarkedFiles.ts"
      provides: "Set-based marked files state with mark/unmark/isMarked/deleteAllMarked"
      exports: ["useMarkedFiles"]
    - path: "src/hooks/useProjectilePool.ts"
      provides: "Object pool for projectile reuse with spawn/despawn"
      exports: ["useProjectilePool"]
    - path: "src/components/Scene/ProjectileManager.tsx"
      provides: "Renders active projectiles with movement and hit detection"
      contains: "useFrame"
    - path: "src/components/Scene/FileBlocks.tsx"
      provides: "Updated file blocks with marked visual state and de-rez animation"
      contains: "markedFiles"
  key_links:
    - from: "src/App.tsx"
      to: "src/hooks/useMarkedFiles.ts"
      via: "Hook usage for mark/delete state"
      pattern: "useMarkedFiles"
    - from: "src/components/Scene/ProjectileManager.tsx"
      to: "src/components/Scene/FileBlocks.tsx"
      via: "Raycasting hit detection against instanced meshes"
      pattern: "intersectObjects"
    - from: "src/hooks/useMarkedFiles.ts"
      to: "src/lib/tauri-commands.ts"
      via: "moveToTrash command for actual file deletion"
      pattern: "commands.moveToTrash"
---

<objective>
Implement the complete shooting and two-shot deletion system: projectile firing from turret, hit detection against file blocks, mark-on-first-hit with pulsing visual feedback, delete-on-second-hit with de-rez dissolution animation, and batch delete via keyboard shortcut.

Purpose: This is the core gameplay loop — the reason TankDelete exists. Shooting files to mark and delete them is the primary interaction.
Output: ProjectileManager.tsx, useMarkedFiles.ts, useProjectilePool.ts, updated FileBlocks.tsx with mark visuals and de-rez, updated App.tsx with shooting integration.
</objective>

<execution_context>
@/Users/zacharyblevins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zacharyblevins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-gameplay/03-RESEARCH.md
@.planning/phases/03-core-gameplay/03-01-SUMMARY.md
@src/App.tsx
@src/components/Scene/Tank.tsx
@src/components/Scene/FileBlocks.tsx
@src/hooks/useFileBlocks.ts
@src/lib/tauri-commands.ts
@src/lib/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create projectile pool, projectile rendering, and hit detection system</name>
  <files>src/hooks/useProjectilePool.ts, src/components/Scene/ProjectileManager.tsx, src/components/Scene/Tank.tsx</files>
  <action>
**useProjectilePool.ts:**
- Manage array of pooled projectile objects: `{ active: boolean, position: Vector3, direction: Vector3, lifetime: number }`
- `spawn(position: Vector3, direction: Vector3)`: find first inactive projectile and activate it, or push new one if pool not at max (maxSize = 20)
- `despawn(index: number)`: set active = false
- `getActive()`: return array of active projectiles with their indices
- Use `useRef` for pool array (NOT useState — pool mutates every frame for position updates, don't want React re-renders)
- Return `{ spawn, despawn, pool }` where pool is the ref

**ProjectileManager.tsx:**
- Receives props: `pool` ref from useProjectilePool, `despawn` function, `onHit: (filePath: string) => void`, `fileBlockRefs: React.RefObject<THREE.InstancedMesh>[]` (refs to instanced meshes for hit detection)
- In useFrame loop for each active projectile:
  1. Move position along direction by PROJECTILE_SPEED * delta
  2. Increment lifetime by delta
  3. If lifetime > PROJECTILE_MAX_LIFETIME, despawn
  4. Raycasting: create raycaster, set from projectile position in projectile direction. Check intersections against all instanced meshes (one per file category)
  5. On intersection: get instanceId from hit, map back to file path via blocks data, call onHit(filePath), despawn projectile
- Pre-allocate raycaster and temp vectors with useMemo
- Render active projectiles as glowing cyan spheres:
  - `sphereGeometry(0.12, 8, 8)` with `meshBasicMaterial` color="#00ffff" toneMapped={false}
  - Share geometry across all projectile meshes with `dispose={null}`
  - The bloom post-processing already present will create the glow trail effect naturally

**Tank.tsx updates:**
- Add mouse click handler for shooting. Use `onPointerDown` on the Canvas or use `useThree` to add event listener
- Actually, use `onPointerDown` on a full-screen invisible mesh, OR handle it in App.tsx and pass callback
- Better approach: Add `onShoot` prop to Tank. In useFrame, listen for mouse click via `state.mouse` — no, useFrame doesn't detect clicks.
- Best approach: In Tank component, use `useEffect` to add 'mousedown' event listener to window. On left click (button 0):
  1. Get turret world position and forward direction
  2. Compute spawn position slightly in front of barrel tip
  3. Call `onShoot(spawnPosition, turretForwardDirection)`
- Compute turret world direction: `turretRef.current.getWorldDirection(tempDirection)` — this gives the forward vector in world space
- Spawn position: turret world position + turretForwardDirection * 0.8 (barrel length)
  </action>
  <verify>
Run `cd /Users/zacharyblevins/Desktop/tankdelete && npx tsc --noEmit` — no type errors.
Verify useProjectilePool.ts exports useProjectilePool.
Verify ProjectileManager.tsx renders active projectiles and checks intersections in useFrame.
Verify Tank.tsx calls onShoot with position and direction on mouse click.
  </verify>
  <done>Clicking mouse fires a glowing cyan projectile from turret barrel. Projectile travels in turret aim direction at constant speed. Projectile despawns after 3 seconds or on hit. Hit detection via raycasting against instanced file block meshes returns file path of hit block.</done>
</task>

<task type="auto">
  <name>Task 2: Implement useMarkedFiles hook, two-shot deletion logic, mark visuals, de-rez animation, and batch delete</name>
  <files>src/hooks/useMarkedFiles.ts, src/components/Scene/FileBlocks.tsx, src/App.tsx</files>
  <action>
**useMarkedFiles.ts:**
- `markedFiles: Set<string>` state (file paths)
- `deletingFiles: Set<string>` state (files currently playing de-rez animation)
- `markFile(filePath)`: add to markedFiles (new Set to trigger re-render)
- `unmarkFile(filePath)`: remove from markedFiles
- `isMarked(filePath)`: check membership
- `startDeletion(filePath)`: remove from markedFiles, add to deletingFiles
- `finishDeletion(filePath)`: remove from deletingFiles
- `deleteAllMarked()`: move all marked files to trash via `commands.moveToTrash`, update session stats, move all to deletingFiles. Use Promise.all for parallel deletion. On each success, call finishDeletion after animation completes (or let FileBlocks manage animation timing).
- `markedCount`: computed from markedFiles.size
- Import commands from tauri-commands.ts

**Two-shot logic in App.tsx:**
- Create `handleProjectileHit(filePath: string)` callback:
  1. If file is already marked (isMarked): start deletion — call `commands.moveToTrash(filePath)`, show toast, update stats, trigger de-rez animation via startDeletion()
  2. If file is NOT marked: call markFile(filePath) — file gets pulsing red/orange glow
- Pass this callback as `onHit` prop through to ProjectileManager
- Add batch delete: add `batchDelete` key to CONTROLS_MAP in App.tsx (`keys: ['Delete', 'KeyX']`). In a useEffect or via a component that reads keyboard controls, when batchDelete pressed and markedFiles.size > 0, call deleteAllMarked(). Use a ref to track last batch delete time to prevent rapid-fire triggering.

**FileBlocks.tsx mark visual updates:**
- Accept new props: `markedFiles: Set<string>`, `deletingFiles: Set<string>`, `onDeletionComplete: (filePath: string) => void`
- In InstancedCategoryBlocks, for each block:
  - If `markedFiles.has(block.path)`: change wireframe color to warning color `#ff4400` (red-orange), add pulsing emissive intensity (sin wave * 0.5 + 1.5 — stronger pulse than idle). Override the category color material for marked instances.
  - Implementation: Since we use InstancedMesh, we can set per-instance color. Use `meshRef.current.setColorAt(i, markedColor)` for marked blocks and `meshRef.current.setColorAt(i, normalColor)` for unmarked. Call `instanceColor.needsUpdate = true`.
  - For wireframe: since wireframes are merged geometry, we can't color individual wires differently easily. Instead, render a second set of wireframe edges for marked blocks in red-orange color, overlaid on top. OR: re-merge wireframes when marked set changes (simpler, and mark changes are infrequent).
  - Simpler approach for mark visual: Add a separate `<mesh>` for each marked file that renders a pulsing glow ring/outline around the marked block position. This avoids touching the instanced rendering pipeline.

**De-rez dissolution animation in FileBlocks.tsx:**
- For blocks in `deletingFiles` set:
  - Track per-block animation progress with a Map<string, number> ref
  - In useFrame: increment progress for each deleting block by delta / DEREZ_DURATION (0.8 seconds)
  - Scale block down: `scale = 1 - progress`
  - Fade opacity: `opacity = 1 - progress`
  - When progress >= 1.0: call onDeletionComplete(filePath), remove from progress map
  - Visual effect: Add particle burst — spawn 8-12 small cubes that fly outward and fade (Tron de-rez feel). Use simple meshes with random velocity vectors, fading opacity.
  - For instanced meshes: set the scale of the deleting instance to shrink via setMatrixAt. Set per-instance color to flash white then fade.

**App.tsx integration:**
- Call useMarkedFiles() hook
- Wire handleProjectileHit to ProjectileManager's onHit
- Pass markedFiles and deletingFiles to FileBlocks
- Add ProjectileManager component inside Scene
- Need to collect refs to instanced meshes from FileBlocks for raycasting. Add a callback prop to FileBlocks that reports mesh refs when mounted: `onMeshRefsReady: (refs: THREE.InstancedMesh[]) => void`. Store in App state/ref and pass to ProjectileManager.
- Also need to pass allBlocks data to ProjectileManager so it can map instanceId back to file path. Pass the blocks Map or a flat lookup.
- After each deletion, remove the file from entries state so it disappears from scene after de-rez completes.
- Update session stats (deletedCount, deletedBytes) after each deletion.
  </action>
  <verify>
Run `cd /Users/zacharyblevins/Desktop/tankdelete && npx tsc --noEmit` — no type errors.
Run `cd /Users/zacharyblevins/Desktop/tankdelete && npm run build` — build succeeds.
Verify useMarkedFiles.ts exports useMarkedFiles with markFile, isMarked, deleteAllMarked.
Verify FileBlocks.tsx accepts markedFiles and deletingFiles props.
Verify App.tsx wires handleProjectileHit through ProjectileManager to FileBlocks.
  </verify>
  <done>First shot on file marks it with pulsing red-orange glow. Second shot triggers moveToTrash and de-rez dissolution animation (shrink + fade over 0.8s). Batch delete via X/Delete key sends all marked files to trash simultaneously. Deleted files removed from scene after animation completes. Session stats update on each deletion.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. useMarkedFiles.ts exports hook with markFile, unmarkFile, isMarked, deleteAllMarked, startDeletion, finishDeletion
4. useProjectilePool.ts exports hook with spawn, despawn, pool ref
5. ProjectileManager.tsx renders projectiles and performs raycasting in useFrame
6. FileBlocks.tsx renders marked files with different color and pulsing animation
7. FileBlocks.tsx handles de-rez animation for deleting files
8. App.tsx integrates two-shot logic: first hit marks, second hit deletes
9. Batch delete key (X or Delete) triggers deleteAllMarked
10. commands.moveToTrash called on second hit and batch delete
</verification>

<success_criteria>
- Mouse click fires glowing projectile from turret barrel in aim direction
- Projectile travels at constant speed and despawns after 3 seconds or on hit
- Hit detection correctly identifies which file block was hit
- First hit on unmarked file: file block changes to pulsing red-orange glow
- Second hit on marked file: file sent to OS trash, de-rez animation plays
- De-rez animation: block shrinks and fades over ~0.8 seconds, then removed from scene
- X or Delete key deletes all currently marked files at once
- Session stats (deleted count, deleted bytes) update correctly
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-gameplay/03-02-SUMMARY.md`
</output>
