---
phase: 01-foundation-safety
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src-tauri/src/models/undo_action.rs
  - src-tauri/src/models/mod.rs
  - src-tauri/src/commands/trash.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/lib/tauri-commands.ts
  - src/lib/types.ts
  - src/components/HUD.tsx
  - src/App.tsx
  - src/App.css
autonomous: false

must_haves:
  truths:
    - "Files moved to recycle bin can be restored (trash integration works)"
    - "User can undo the last deletion with Ctrl+Z"
    - "HUD shows running total of files deleted and MB freed this session"
    - "Toast notification appears after delete with file name, size, and undo hint"
  artifacts:
    - path: "src-tauri/src/commands/trash.rs"
      provides: "Trash operations and undo stack"
      exports: ["move_to_trash", "undo_last_trash", "get_session_stats"]
    - path: "src-tauri/src/models/undo_action.rs"
      provides: "TrashAction struct and UndoStack managed state"
      contains: "pub struct UndoStack"
    - path: "src/components/HUD.tsx"
      provides: "Heads-up display with session stats"
      min_lines: 30
  key_links:
    - from: "src/App.tsx"
      to: "src/components/HUD.tsx"
      via: "Renders HUD component in ready state"
      pattern: "<HUD"
    - from: "src/App.tsx"
      to: "src/lib/tauri-commands.ts"
      via: "commands.moveToTrash() and commands.undoLastTrash()"
      pattern: "commands\\.(moveToTrash|undoLastTrash)"
    - from: "src-tauri/src/commands/trash.rs"
      to: "src-tauri/src/models/undo_action.rs"
      via: "Uses UndoStack managed state"
      pattern: "State.*UndoStack"
    - from: "src/App.tsx"
      to: "Ctrl+Z keyboard listener"
      via: "useEffect keydown handler calling undoLastTrash"
      pattern: "keydown.*ctrlKey.*KeyZ|metaKey.*KeyZ"

user_setup: []
---

<objective>
Implement the trash system with OS recycle bin integration, session undo stack, and HUD overlay showing deletion stats -- completing the safety infrastructure for Phase 1.

Purpose: This is the core safety layer that makes file deletion reversible. The undo stack and trash integration ensure users can always recover from mistakes, which is critical before adding gameplay mechanics in Phase 3.

Output: Working trash-to-recycle-bin pipeline, unlimited session undo via Ctrl+Z, HUD with running file/size counters, and toast notifications on delete/undo actions.
</objective>

<execution_context>
@/Users/zacharyblevins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zacharyblevins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-safety/01-CONTEXT.md
@.planning/phases/01-foundation-safety/01-RESEARCH.md
@.planning/phases/01-foundation-safety/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Rust trash commands and undo stack</name>
  <files>
    src-tauri/src/models/undo_action.rs
    src-tauri/src/models/mod.rs
    src-tauri/src/commands/trash.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    Implement the trash system in Rust with Command pattern undo stack.

    **src-tauri/src/models/undo_action.rs:**
    - TrashAction struct: { file_path: String, file_name: String, original_size: u64, trash_timestamp: u64 }
    - Derive Serialize, Deserialize, Debug, Clone
    - UndoStack struct with:
      - actions: Mutex<VecDeque<TrashAction>> (VecDeque for efficient pop_front if limit reached)
      - max_size: usize (set to 1000 per research recommendation -- Claude's discretion on undo stack memory)
      - total_deleted_count: Mutex<u64> (session counter)
      - total_deleted_bytes: Mutex<u64> (session counter)
    - UndoStack methods: new(max_size), push(action), pop() -> Option<TrashAction>, stats() -> (u64, u64)
    - On push: if at max_size, pop_front oldest before pushing

    **src-tauri/src/commands/trash.rs:**

    `move_to_trash(path: String, undo_stack: State<UndoStack>) -> Result<TrashAction, String>`:
    - Get file metadata (size) before deletion
    - Call `trash::delete(&path)` to move to OS recycle bin (per user decision: use OS native trash)
    - Create TrashAction with file info and current timestamp
    - Push to undo_stack
    - Increment session counters (total_deleted_count, total_deleted_bytes)
    - Return the TrashAction (frontend needs file_name and original_size for toast)

    `undo_last_trash(undo_stack: State<UndoStack>) -> Result<Option<TrashAction>, String>`:
    - Pop from undo_stack
    - If Some(action): attempt to restore file from trash
    - IMPORTANT (per research Pitfall #2): The `trash` crate has NO restore function. Strategy:
      - On macOS: Use `std::process::Command` to run AppleScript: `tell app "Finder" to move (POSIX file "/path/.Trash/filename") to (POSIX file "/original/path/")`
      - Alternatively: Before calling trash::delete, COPY the file to a temp staging area, then on undo, move it back from staging. This is more reliable cross-platform.
      - RECOMMENDED APPROACH: Use the `trash` crate's `os_limited::list()` and `os_limited::purge_all()` functions if available, OR implement a simpler approach: before trashing, record the original path; on undo, search the OS trash for the file by name+timestamp and move it back.
      - SIMPLEST RELIABLE APPROACH: Before trash::delete, copy file to a temp dir (e.g., app_data_dir/.undo_staging/). On undo, move from staging back to original path. On app close or stack eviction, clean up staging dir. This guarantees restore works cross-platform.
    - Decrement session counters on successful undo
    - Return the restored TrashAction (frontend needs info for toast)

    `get_session_stats(undo_stack: State<UndoStack>) -> Result<(u64, u64), String>`:
    - Return (total_deleted_count, total_deleted_bytes) from undo_stack

    **lib.rs updates:**
    - Add `.manage(UndoStack::new(1000))` to Tauri builder
    - Register new commands: move_to_trash, undo_last_trash, get_session_stats
    - Export trash module from commands/mod.rs

    NOTE on trash restore: The staging directory approach is safest. Create the staging dir at app_data_dir (via Tauri's path API) / ".undo_staging". On push to undo stack, copy file there. On pop (undo), move back. On eviction from stack (oldest removed), delete from staging. On app exit, clean up entire staging dir.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- compiles without errors.
    Run `cd src-tauri && cargo test` -- unit tests for UndoStack pass (push, pop, max_size eviction, stats counting).
  </verify>
  <done>
    Three Tauri commands exist and compile: move_to_trash (copies to staging then trashes via OS recycle bin), undo_last_trash (restores from staging to original path), get_session_stats (returns session counters). UndoStack manages up to 1000 actions with staging directory for reliable cross-platform restore.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build React HUD, toast notifications, and Ctrl+Z undo integration</name>
  <files>
    src/lib/tauri-commands.ts
    src/lib/types.ts
    src/components/HUD.tsx
    src/App.tsx
    src/App.css
  </files>
  <action>
    Build the frontend integration for trash operations, HUD display, and undo keybinding.

    **src/lib/types.ts -- add:**
    - TrashAction interface: { file_path: string; file_name: string; original_size: number; trash_timestamp: number }
    - SessionStats interface: { deleted_count: number; deleted_bytes: number }

    **src/lib/tauri-commands.ts -- add commands:**
    - moveToTrash(path: string): Promise<TrashAction>
    - undoLastTrash(): Promise<TrashAction | null>
    - getSessionStats(): Promise<[number, number]> (tuple: count, bytes)

    **src/components/HUD.tsx:**
    - Positioned fixed at top-right of screen (per Claude's discretion on positioning)
    - Displays: "Files deleted: {count} | Freed: {formattedBytes}"
    - Semi-transparent dark background with Tron cyan (#00ffff) text
    - Monospace font for counters
    - Updates in real-time when session stats change
    - Receives deletedCount and deletedBytes as props (parent manages state)
    - Only visible when at least 1 file has been deleted (hide when 0)
    - Per user decision: "Running HUD counter: total files deleted and total MB freed this session"

    **Install react-hot-toast:** `bun add react-hot-toast` (per research recommendation)

    **src/App.tsx updates:**

    1. Add session stats state: { deletedCount: number, deletedBytes: number }

    2. Add Toaster component from react-hot-toast:
       - Position: "top-right" (below HUD)
       - Style toasts with dark theme matching Tron aesthetic
       - Duration: 4000ms (per Claude's discretion)

    3. Add delete handler (for testing -- in Phase 1, trigger from file list click):
       - Call commands.moveToTrash(filePath)
       - On success: show toast "Deleted {fileName} ({formattedSize}) -- Ctrl+Z to undo" (per user decision on toast format)
       - Update session stats state
       - Remove deleted file from the file list state
       - On error: show error toast

    4. Add Ctrl+Z keybinding via useEffect:
       - Listen for keydown events
       - Check for (e.ctrlKey || e.metaKey) && e.key === 'z' (metaKey for macOS Cmd+Z)
       - Call commands.undoLastTrash()
       - On success (non-null result): show toast "Restored {fileName}" (per user decision: "clear but not disruptive")
       - Update session stats (decrement)
       - Re-add restored file to file list state at its original position
       - On null (nothing to undo): no-op, don't show toast
       - Prevent default browser undo behavior with e.preventDefault()

    5. Add delete button to file list items:
       - Small "x" or trash icon button next to each file entry
       - On click: call the delete handler
       - Do NOT add delete button to directory entries (only files)
       - This is temporary -- Phase 3 replaces with shooting mechanic

    6. Render HUD component when in "ready" state

    **src/App.css updates:**
    - HUD styling: fixed position, top-right, semi-transparent bg, cyan text
    - Toast overrides: dark background (#1a1a2e), cyan border, light text
    - Delete button styling: small, subtle, red on hover
    - File list item hover state
  </action>
  <verify>
    Run `bun run tauri dev` -- app launches.
    Click delete on a file -- file moves to OS trash, toast shows, HUD counter updates.
    Press Ctrl+Z (or Cmd+Z on macOS) -- file is restored, toast confirms, HUD counter decrements.
    Delete multiple files -- HUD shows cumulative count and size.
    Verify deleted files appear in OS trash (macOS: open Trash in Finder).
  </verify>
  <done>
    Trash system fully operational: files move to OS recycle bin on delete, restore on Ctrl+Z undo, HUD shows running session stats, toast notifications confirm every action. Session supports unlimited undo (up to 1000 actions).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete Phase 1 flow</name>
  <files>no files modified -- verification only</files>
  <action>
    Human verification checkpoint. Present the verification steps to the user and wait for approval. No code changes in this task -- purely manual testing of the complete Phase 1 flow built in Plans 01 and 02.
  </action>
  <verify>
    User confirms all 10 verification steps pass (see how-to-verify below).
  </verify>
  <done>
    User has approved the complete Phase 1 flow: directory picker, file scanning, trash integration, undo, HUD, and persistence all working correctly.
  </done>
  <what-built>
    Complete Tauri v2 desktop app with:
    - Native directory picker on launch (blocks system dirs, filters hidden files)
    - Recursive file scanning with size computation
    - Last-used directory persistence across app restarts
    - OS trash integration (files go to real recycle bin)
    - Session undo stack with Ctrl+Z (restores files from trash)
    - HUD showing files deleted count and MB freed
    - Toast notifications on delete and undo
  </what-built>
  <how-to-verify>
    1. Run `bun run tauri dev` -- app should launch and show directory picker
    2. Pick a test directory (create one with dummy files if needed)
    3. Verify file list shows files and folders with correct sizes
    4. Verify hidden files (.git, .DS_Store, etc.) are NOT shown
    5. Click delete on a test file:
       - Toast appears: "Deleted filename (size) -- Ctrl+Z to undo"
       - HUD counter appears showing "Files deleted: 1 | Freed: XX KB"
       - File disappears from list
       - Check OS Trash -- file should be there
    6. Press Cmd+Z (macOS) or Ctrl+Z:
       - Toast appears: "Restored filename"
       - File reappears in list
       - HUD counter decrements
       - Check OS Trash -- file should be gone (restored)
    7. Delete multiple files, verify cumulative HUD stats
    8. Close and reopen app -- should offer to reopen last directory
    9. Try selecting /System or /usr -- should be blocked
    10. Cancel the directory picker -- should re-show after brief delay
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` -- Rust compiles
2. `bun run tauri dev` -- App launches
3. Delete a file -- appears in OS trash, toast shown, HUD updates
4. Ctrl+Z/Cmd+Z -- file restored from trash, toast shown, HUD updates
5. Multiple deletes -- HUD accumulates correctly
6. App restart -- last directory remembered
7. Full ENGN-01 satisfied: directory picker on launch
8. Full DELT-02 satisfied: second shot sends to recycle bin (simulated via click for now)
9. Full DELT-04 satisfied: Ctrl+Z undo restores file
</verification>

<success_criteria>
- Files successfully move to OS recycle bin when deleted
- Ctrl+Z restores the most recently deleted file from trash
- HUD displays accurate running totals of files deleted and bytes freed
- Toast notifications appear for delete and undo actions
- Undo stack supports full session history (up to 1000 actions)
- All Phase 1 success criteria met (picker, filesystem access, trash restore, undo)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-safety/01-02-SUMMARY.md`
</output>
