---
phase: 01-foundation-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - vite.config.ts
  - index.html
  - src/main.tsx
  - src/App.tsx
  - src/App.css
  - src/lib/tauri-commands.ts
  - src/lib/format.ts
  - src/lib/types.ts
  - src/components/DirectoryPicker.tsx
  - src-tauri/Cargo.toml
  - src-tauri/tauri.conf.json
  - src-tauri/capabilities/default.json
  - src-tauri/src/lib.rs
  - src-tauri/src/models/mod.rs
  - src-tauri/src/models/file_entry.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/directory.rs
  - src-tauri/src/commands/store.rs
autonomous: true

must_haves:
  truths:
    - "User can launch the Tauri app and see a native directory picker dialog"
    - "User can select a starting directory which the app reads and lists files from"
    - "System directories are blocked from selection"
    - "Hidden files/dotfiles are filtered out of scan results"
    - "Last-used directory is remembered between app launches"
  artifacts:
    - path: "src-tauri/src/commands/directory.rs"
      provides: "Directory picker, system dir blocklist, recursive scanning with hidden file filter"
      exports: ["pick_directory", "scan_directory"]
    - path: "src-tauri/src/commands/store.rs"
      provides: "Last directory persistence via Tauri Store"
      exports: ["save_last_directory", "get_last_directory"]
    - path: "src-tauri/src/models/file_entry.rs"
      provides: "FileEntry struct shared between Rust and TypeScript"
      contains: "pub struct FileEntry"
    - path: "src/lib/tauri-commands.ts"
      provides: "Type-safe invoke wrappers for all Tauri commands"
      exports: ["commands"]
    - path: "src/App.tsx"
      provides: "Root component with directory picker launch flow"
      min_lines: 40
    - path: "src-tauri/capabilities/default.json"
      provides: "Tauri v2 security permissions for dialog, fs, store"
      contains: "dialog:allow-open"
  key_links:
    - from: "src/App.tsx"
      to: "src/lib/tauri-commands.ts"
      via: "commands.pickDirectory() and commands.scanDirectory()"
      pattern: "commands\\.(pickDirectory|scanDirectory)"
    - from: "src/lib/tauri-commands.ts"
      to: "src-tauri/src/commands/directory.rs"
      via: "invoke('pick_directory') and invoke('scan_directory')"
      pattern: "invoke.*pick_directory|invoke.*scan_directory"
    - from: "src-tauri/src/commands/directory.rs"
      to: "src-tauri/src/models/file_entry.rs"
      via: "Returns Vec<FileEntry>"
      pattern: "Vec<FileEntry>"
---

<objective>
Create the Tauri v2 desktop app scaffold with directory picker, filesystem scanning, and persistence -- the complete directory selection vertical slice.

Purpose: Establishes the runnable app shell and the core directory system that all subsequent phases build on. After this plan, a user can launch the app, pick a directory, and see their files listed.

Output: Working Tauri v2 app with React frontend, directory picker flow, recursive file scanning, system directory blocking, hidden file filtering, and last-directory persistence.
</objective>

<execution_context>
@/Users/zacharyblevins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zacharyblevins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-safety/01-CONTEXT.md
@.planning/phases/01-foundation-safety/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Tauri v2 project with all dependencies and configuration</name>
  <files>
    package.json
    tsconfig.json
    vite.config.ts
    index.html
    src/main.tsx
    src-tauri/Cargo.toml
    src-tauri/tauri.conf.json
    src-tauri/capabilities/default.json
    src-tauri/src/lib.rs
    src-tauri/src/models/mod.rs
    src-tauri/src/models/file_entry.rs
    src-tauri/src/commands/mod.rs
  </files>
  <action>
    Create a new Tauri v2 project using `bun create tauri-app` with React + TypeScript + Vite template. Project name: tankdelete. Run from the project root (the repo already exists, so scaffold into it or create and move files).

    After scaffolding:

    1. Add Tauri plugins:
       - `bun run tauri add dialog`
       - `bun run tauri add fs`
       - `bun run tauri add store`

    2. Add Rust crate dependencies in src-tauri/Cargo.toml:
       - `trash = "5"` (OS trash integration)
       - `walkdir = "2"` (recursive directory traversal)
       - `serde_json = "1"` (should already be there via Tauri)

    3. Configure src-tauri/capabilities/default.json with permissions:
       - `dialog:default` (allows open dialog)
       - `store:default` (allows store operations)
       - Core permissions for window management
       - NOTE: The dialog plugin auto-expands filesystem scopes when user picks a directory, so no broad fs:allow-read needed initially

    4. Configure src-tauri/tauri.conf.json:
       - Window title: "TankDelete"
       - Window starts maximized (per Claude's discretion -- maximized windowed allows menubar access)
       - Window minimum size: 800x600

    5. Set up Rust module structure:
       - src-tauri/src/models/mod.rs (exports file_entry)
       - src-tauri/src/models/file_entry.rs (FileEntry struct with path: String, name: String, size: u64, is_dir: bool, extension: Option<String>)
       - src-tauri/src/commands/mod.rs (exports directory, store)
       - src-tauri/src/lib.rs (register plugins, manage state, register command handlers)

    6. Verify the project compiles: `cd src-tauri && cargo check`

    Use Bun as the package manager (not npm/yarn) per user decision. TypeScript throughout per user decision.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- should compile without errors.
    Run `bun run tauri info` -- should show Tauri v2 with all plugins listed.
  </verify>
  <done>
    Tauri v2 project exists with React+TS+Vite, all plugins installed, Rust module structure created with FileEntry model, capabilities configured, and the project compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Rust directory commands -- picker, scanner, blocklist, persistence</name>
  <files>
    src-tauri/src/commands/directory.rs
    src-tauri/src/commands/store.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    Implement the Rust backend commands for the directory system.

    **directory.rs -- pick_directory command:**
    - Use `tauri_plugin_dialog::DialogExt` to show native folder picker
    - Set dialog title to "Select Directory to Explore"
    - On selection, validate against system directory blocklist using `is_system_directory()` function
    - System directory blocklist (Claude's discretion on exact list):
      - macOS: /System, /Library, /usr, /bin, /sbin, /etc, /var, /private, /cores, /dev
      - Windows: C:\Windows, C:\Program Files, C:\Program Files (x86), C:\ProgramData, C:\$Recycle.Bin, C:\System Volume Information
      - Linux: /bin, /boot, /dev, /etc, /lib, /lib64, /proc, /root, /sbin, /sys, /usr, /var
    - Use `#[cfg(target_os = "...")]` for platform-specific blocklists
    - Return Ok(Some(path)) on valid selection, Ok(None) on cancel, Err on blocked directory

    **directory.rs -- scan_directory command:**
    - Accept path: String, use `walkdir::WalkDir` for recursive traversal
    - Set `follow_links(false)` to avoid symlink loops
    - Filter out hidden entries using `is_hidden()` function:
      - Unix: filename starts with '.'
      - Windows: check FILE_ATTRIBUTE_HIDDEN via `MetadataExt` (use `#[cfg(windows)]`)
    - When a directory is hidden, skip its entire subtree (use `filter_entry` on WalkDir)
    - For each visible entry, create FileEntry with: path, name (filename), size, is_dir, extension
    - Return only the DIRECT children of the given path (depth 1) for display, but also compute recursive sizes for subdirectories
    - For subdirectory size calculation: use a separate recursive walk per subdirectory (or a single walk with path-based grouping) to get total nested size
    - Emit scan progress via `app.emit("scan_progress", ...)` every 100 entries during recursive size computation (per research Pattern 6/Pitfall 7)
    - Return Vec<FileEntry> sorted: directories first, then files, alphabetically within each group

    **store.rs -- persistence commands:**
    - `save_last_directory(path: String)` -- save to Tauri Store under key "lastDirectory"
    - `get_last_directory()` -- retrieve from store, return Option<String>
    - Use `tauri_plugin_store::StoreExt` to access the store

    **lib.rs updates:**
    - Register all commands in invoke_handler: pick_directory, scan_directory, save_last_directory, get_last_directory
    - Register all plugins: dialog, fs, store
    - No managed state needed yet (undo stack comes in Plan 02)

    IMPORTANT: Use async Tauri commands where appropriate. The scan_directory command should use `tauri::async_runtime::spawn_blocking` for the walkdir traversal to avoid blocking the async runtime (per research anti-patterns).
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- all commands compile.
    Run `cd src-tauri && cargo test` -- any unit tests pass (add basic test for is_system_directory and is_hidden if feasible).
  </verify>
  <done>
    Four Tauri commands exist and compile: pick_directory (with blocklist validation), scan_directory (recursive with hidden filter and progress events), save_last_directory, get_last_directory. System directories are blocked. Hidden files are filtered. Subdirectory sizes are computed recursively.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build React frontend -- launch flow, directory picker loop, file list display</name>
  <files>
    src/main.tsx
    src/App.tsx
    src/App.css
    src/lib/tauri-commands.ts
    src/lib/format.ts
    src/lib/types.ts
    src/components/DirectoryPicker.tsx
  </files>
  <action>
    Build the React frontend that implements the directory picker launch flow.

    **src/lib/types.ts:**
    - FileEntry interface matching Rust struct: { path: string; name: string; size: number; is_dir: boolean; extension: string | null }
    - ScanProgress interface: { files_scanned: number; total_bytes: number }

    **src/lib/format.ts:**
    - formatBytes(bytes: number): string -- human-readable file sizes (B, KB, MB, GB) using 1024 base
    - formatDate(timestamp: number): string -- for future use

    **src/lib/tauri-commands.ts:**
    - Type-safe wrappers around all invoke calls:
      - pickDirectory(): Promise<string | null>
      - scanDirectory(path: string): Promise<FileEntry[]>
      - saveLastDirectory(path: string): Promise<void>
      - getLastDirectory(): Promise<string | null>
    - Export as `commands` object

    **src/App.tsx -- Main launch flow:**
    - State machine with states: "checking" | "picking" | "scanning" | "ready"
    - On mount ("checking" state):
      1. Call commands.getLastDirectory()
      2. If last dir exists, show a prompt: "Reopen [dirname]?" with Yes/Pick New buttons
      3. If no last dir, go straight to "picking" state
    - "picking" state: call commands.pickDirectory()
      - If result is null (cancelled), wait 500ms then re-call (per research Pitfall #3 -- small delay before re-showing)
      - If result is error (blocked dir), show brief error message, re-pick
      - If result is valid path, save via commands.saveLastDirectory(), transition to "scanning"
    - "scanning" state: call commands.scanDirectory(path)
      - Listen for "scan_progress" events from Tauri to show scanning status
      - On complete, store FileEntry[] in state, transition to "ready"
    - "ready" state: render the directory contents

    **src/components/DirectoryPicker.tsx:**
    - Simple component for the "picking" state UI
    - Shows "Select a directory to explore" message
    - Shows "Reopen [last dir]?" option when applicable
    - Minimal styling -- dark background (#0a0a0a), Tron-ish cyan accent (#00ffff) for text
    - This is temporary UI that will be replaced by the 3D scene in Phase 2

    **src/App.css:**
    - Dark theme base: background #0a0a0a, text color #e0e0e0
    - Tron accent color: #00ffff (cyan)
    - Basic file list styling: monospace font for file entries, size right-aligned
    - Directory entries highlighted differently from files

    **"ready" state rendering (in App.tsx):**
    - Display current directory path at top
    - List FileEntry items: icon indicator (folder vs file), name, formatted size, extension
    - Directories listed first, then files (already sorted by backend)
    - "Change Directory" button to re-enter picker flow
    - This is a temporary list view -- Phase 2 replaces it with 3D

    **src/main.tsx:**
    - Standard React 18 createRoot entry point
    - Import App.css

    Keep the UI minimal and functional -- this is scaffolding. The 3D scene replaces it in Phase 2. Focus on correctness of the directory flow, not visual polish.
  </action>
  <verify>
    Run `bun run tauri dev` -- app launches, shows directory picker, selecting a folder lists its contents.
    Verify: cancelling picker re-shows it after brief delay.
    Verify: selecting a system directory shows error and re-picks.
    Verify: restarting app offers to reopen last directory.
  </verify>
  <done>
    App launches and immediately shows directory picker. User can select a directory and see its files/folders listed with names and sizes. System directories are blocked. Hidden files are filtered. Last directory is persisted and offered on relaunch. Cancelling picker re-shows it.
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` -- Rust compiles without errors
2. `bun run tauri dev` -- App launches successfully
3. Directory picker appears on launch
4. Selecting a valid directory shows file listing
5. Cancelling picker re-shows it after delay
6. System directory selection is rejected
7. Restart app -- last directory is offered
8. Hidden files (.git, .env, etc.) do not appear in file list
</verification>

<success_criteria>
- Tauri v2 app runs with React+TS+Vite frontend
- Native directory picker works with validation and persistence
- Recursive file scanning returns filtered, sorted results
- Frontend displays directory contents with file metadata
- All Tauri plugins (dialog, fs, store) operational
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-safety/01-01-SUMMARY.md`
</output>
