---
phase: 04-game-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useScore.ts
  - src/components/HUD/ScoreCounter.tsx
  - src/components/HUD/ScoreCounter.css
  - src/lib/achievements.ts
  - src/hooks/useAchievements.ts
  - src/components/HUD/AchievementToast.tsx
  - src/components/HUD/AchievementToast.css
  - src/hooks/useExplosionPool.ts
  - src/components/Scene/ExplosionParticles.tsx
autonomous: true

must_haves:
  truths:
    - "Score hook calculates 1 point per MB freed from byte count"
    - "ScoreCounter animates number transitions with ease-out curve"
    - "Achievement definitions include three Tron-themed milestones at 100MB, 1GB, 10GB"
    - "AchievementToast renders with neon glow Tron styling"
    - "ExplosionParticles renders voxel cube shatter with category-colored particles"
    - "Explosion pool manages spawn/despawn lifecycle with max 2000 particle budget"
  artifacts:
    - path: "src/hooks/useScore.ts"
      provides: "Score state management hook"
      exports: ["useScore"]
    - path: "src/components/HUD/ScoreCounter.tsx"
      provides: "Animated score display component"
      exports: ["ScoreCounter"]
    - path: "src/lib/achievements.ts"
      provides: "Achievement definitions and types"
      exports: ["ACHIEVEMENTS", "Achievement"]
    - path: "src/hooks/useAchievements.ts"
      provides: "Achievement tracking hook"
      exports: ["useAchievements"]
    - path: "src/components/HUD/AchievementToast.tsx"
      provides: "Custom toast component for achievements"
      exports: ["AchievementToast"]
    - path: "src/hooks/useExplosionPool.ts"
      provides: "Explosion lifecycle management"
      exports: ["useExplosionPool"]
    - path: "src/components/Scene/ExplosionParticles.tsx"
      provides: "InstancedMesh voxel shatter particle system"
      exports: ["ExplosionParticles"]
  key_links:
    - from: "src/hooks/useScore.ts"
      to: "byte count input"
      via: "Math.floor(bytes / (1024 * 1024))"
      pattern: "Math\\.floor.*1024.*1024"
    - from: "src/hooks/useAchievements.ts"
      to: "src/lib/achievements.ts"
      via: "imports ACHIEVEMENTS array"
      pattern: "import.*ACHIEVEMENTS.*from"
    - from: "src/components/Scene/ExplosionParticles.tsx"
      to: "useFrame render loop"
      via: "InstancedMesh matrix updates per frame"
      pattern: "useFrame.*instanceMatrix\\.needsUpdate"
---

<objective>
Create all scoring, achievement, and explosion particle artifacts for Phase 4 game polish.

Purpose: Build the standalone hooks and components that provide gamification feedback. These are created as independent modules first, then wired into App.tsx in Plan 02.
Output: 7 new files - 3 hooks, 3 UI components (with CSS), 1 achievement definitions module.
</objective>

<execution_context>
@/Users/zacharyblevins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zacharyblevins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-game-polish/04-RESEARCH.md

@src/hooks/useProjectilePool.ts
@src/components/Scene/Particles.tsx
@src/lib/colors.ts
@src/hooks/useFileBlocks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create score hook, score counter component, and achievement system</name>
  <files>
    src/hooks/useScore.ts
    src/components/HUD/ScoreCounter.tsx
    src/components/HUD/ScoreCounter.css
    src/lib/achievements.ts
    src/hooks/useAchievements.ts
    src/components/HUD/AchievementToast.tsx
    src/components/HUD/AchievementToast.css
  </files>
  <action>
    Create the scoring and achievement system across 7 files:

    **src/hooks/useScore.ts:**
    - useState for `score` (number, starts 0) and `totalBytesFreed` (number, starts 0)
    - `addPoints(bytesFreed: number)` callback: calculates points as `Math.floor(bytesFreed / (1024 * 1024))`, adds to score, adds bytesFreed to totalBytesFreed, returns points earned
    - Session-scoped (never resets) per user decision
    - Export: `{ score, totalBytesFreed, addPoints }`

    **src/components/HUD/ScoreCounter.tsx:**
    - Props: `{ targetScore: number }`
    - Uses requestAnimationFrame to animate displayScore from current to target
    - Duration: `Math.min(Math.abs(diff) * 2, 1000)` (2ms per point, max 1 second)
    - Easing: ease-out cubic `1 - Math.pow(1 - progress, 3)`
    - On new targetScore while animating: cancel previous animation, start from current displayScore
    - Renders: div.score-counter > div.score-label "SCORE" + div.score-value with toLocaleString()
    - Use `font-variant-numeric: tabular-nums` to prevent layout shift

    **src/components/HUD/ScoreCounter.css:**
    - Fixed position top-right (top: 20px, right: 20px)
    - Dark translucent background rgba(5, 5, 16, 0.85)
    - Cyan border (2px solid #00ffff) with neon glow box-shadow (multiple stacked shadows)
    - Score label: 11px, cyan, letter-spacing 2px, text-shadow neon glow
    - Score value: 28px, white, strong neon glow text-shadow, monospace font
    - z-index: 1000 to match existing HUD

    **src/lib/achievements.ts:**
    - Export `Achievement` interface: `{ id: string, name: string, threshold: number }`
    - Export `ACHIEVEMENTS` array with exactly 3 entries per user decision:
      - `{ id: 'derezzer', name: 'Derezzer', threshold: 100 * 1024 * 1024 }` (100MB)
      - `{ id: 'grid-cleaner', name: 'Grid Cleaner', threshold: 1024 * 1024 * 1024 }` (1GB)
      - `{ id: 'system-purge', name: 'System Purge', threshold: 10 * 1024 * 1024 * 1024 }` (10GB)

    **src/hooks/useAchievements.ts:**
    - Takes `totalBytesFreed: number` parameter
    - useState for `earned: Set<string>` (achievement IDs already earned)
    - useEffect watching totalBytesFreed: iterate ACHIEVEMENTS, if threshold met and not already earned, add to earned set and trigger `toast.custom()` with AchievementToast component
    - Queue multiple achievements with 2-second spacing if earned simultaneously (e.g., batch delete crossing 100MB and 1GB at once)
    - Export: `{ earned }`

    **src/components/HUD/AchievementToast.tsx:**
    - Props: `{ achievement: Achievement, visible: boolean }`
    - Layout: flex row with icon area (trophy emoji with cyan drop-shadow) and text area
    - Text: "ACHIEVEMENT UNLOCKED" label (10px, cyan, uppercase, letter-spacing) + achievement name (18px, white, neon glow)
    - Slide-in animation via CSS class toggle on `visible` prop
    - Dark background matching Tron theme (rgba(5, 5, 16, 0.95))
    - Cyan border with multi-layer neon glow box-shadow

    **src/components/HUD/AchievementToast.css:**
    - Toast container: dark bg, cyan border, neon glow box-shadow (3 layers), border-radius 8px
    - Invisible by default (opacity 0, translateY -20px)
    - `.visible` class: opacity 1, translateY 0, transition 0.4s cubic-bezier(0.16, 1, 0.3, 1)
    - Icon: 32px, cyan drop-shadow filter
    - Label: uppercase, cyan, neon text-shadow
    - Name: 18px, white, subtle neon text-shadow
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify all 7 files compile without type errors. Check that imports between useAchievements and achievements.ts resolve correctly.
  </verify>
  <done>
    All 7 files exist and compile. useScore returns score/totalBytesFreed/addPoints. ScoreCounter animates with rAF. ACHIEVEMENTS has 3 Tron-themed entries. useAchievements triggers toasts on threshold crossings. AchievementToast renders with neon Tron styling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create explosion particle system with InstancedMesh pooling</name>
  <files>
    src/hooks/useExplosionPool.ts
    src/components/Scene/ExplosionParticles.tsx
  </files>
  <action>
    Create the voxel shatter explosion system following existing InstancedMesh patterns from Particles.tsx:

    **src/hooks/useExplosionPool.ts:**
    - Explosion interface: `{ id: number, position: THREE.Vector3, color: string, scale: number, spawnTime: number }`
    - useState for `explosions: Explosion[]`
    - useRef for nextId counter (not useState to avoid re-renders)
    - `spawn(position: THREE.Vector3, color: string, scale: number)`: creates Explosion with position.clone(), performance.now() timestamp, adds to array
    - `despawn(id: number)`: removes explosion from array by id
    - Cleanup: useEffect return that clears all explosions on unmount (prevents memory leak on directory navigation)
    - Export: `{ explosions, spawn, despawn }`

    **src/components/Scene/ExplosionParticles.tsx:**
    - Props: `{ explosions: Explosion[], onExplosionComplete: (id: number) => void }`
    - Single InstancedMesh with boxGeometry(0.15, 0.15, 0.15) for voxel cubes
    - Max 2000 particles budget across all simultaneous explosions
    - Pre-allocated particle data array (like Particles.tsx pattern): each slot has active, explosionId, position (Vector3), velocity (Vector3), color (Color), scale, life, maxLife
    - Pre-allocated temp objects: tempMatrix, tempPosition, tempQuaternion, tempScale (matching existing pattern)

    **useFrame logic:**
    1. For each explosion, on first frame (age < delta): spawn particles into inactive slots
       - Particle count scales with file scale: `Math.min(Math.max(Math.floor(scale * 200), 20), 500)` (20 for tiny files, up to 500 for huge)
       - Random scatter velocity: outward in XZ plane (angle random 0-2PI, speed 2-5), upward bias (0.5-2.0)
       - Particle maxLife: 1.0 + random * 0.5 seconds
       - Particle base scale: 0.08 + random * 0.08
       - Color from explosion.color

    2. Update all active particles each frame:
       - Apply velocity with half-gravity (velocity.y -= 4.9 * delta) for floaty digital feel
       - Advance position by velocity * delta
       - Advance life by delta
       - Fade scale: `baseScale * (1 - life/maxLife)` for dissolve effect
       - If life >= maxLife: deactivate particle

    3. Check explosion completion: if age > 2.5s and no active particles for that explosionId, call onExplosionComplete(id)

    4. Update instanceMatrix and instanceColor needsUpdate flags

    **Material:** meshStandardMaterial with vertexColors for per-instance colors, emissive white at 0.5 intensity, toneMapped false (for bloom interaction)

    IMPORTANT: Use setColorAt for per-instance colors. Initialize instanceColor buffer in useEffect by setting all colors once.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify both files compile. Confirm ExplosionParticles follows same InstancedMesh pattern as existing Particles.tsx (useFrame with pre-allocated objects, instanceMatrix.needsUpdate).
  </verify>
  <done>
    useExplosionPool manages spawn/despawn lifecycle. ExplosionParticles renders voxel cube particles with category colors, gravity, and fade-out. Particle count scales 20-500 based on file scale. Max 2000 particle budget enforced.
  </done>
</task>

</tasks>

<verification>
- All 9 new files compile with `npx tsc --noEmit`
- No modifications to existing files (all wiring happens in Plan 02)
- Hooks export correct interfaces for App.tsx integration
- ExplosionParticles follows InstancedMesh patterns from existing Particles.tsx
- Achievement definitions match user's Tron-themed names exactly
</verification>

<success_criteria>
- useScore.addPoints(524288000) returns 500 (500MB = 500 points)
- ScoreCounter animates between values with rAF
- ACHIEVEMENTS array has exactly 3 entries: Derezzer (100MB), Grid Cleaner (1GB), System Purge (10GB)
- useAchievements triggers toast when threshold crossed
- ExplosionParticles accepts explosions array and renders InstancedMesh with per-instance colors
- All files pass TypeScript compilation
</success_criteria>

<output>
After completion, create `.planning/phases/04-game-polish/04-01-SUMMARY.md`
</output>
